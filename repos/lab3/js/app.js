//Получаем высоту и ширину области, в которой отображается HTML документ в пикселях
var WIDTH = window.innerWidth;
var HEIGHT = window.innerHeight;

//Создаем экземпляр средства визуализации, параметр передаваемый в конструктов (antialias) со значением true указывает, что необходимо выполнить сглаживание
var renderer = new THREE.WebGLRenderer({antialias:true});
//Указываем отображаемую область, в данном случае - это весь экран
renderer.setSize(WIDTH, HEIGHT);
//Устанавливаем на фон белый цвет
renderer.setClearColor(0xFFFFFF, 1);
//Установка визуализации в теге body
document.body.appendChild(renderer.domElement);

//Создаем экземпляр сцены. Сцена позволяет настроить, что и где должно отображаться, например объекты, источники света и камеры
var scene = new THREE.Scene();

/**
 * Экземпляр класса "камера с перспективной проекцией", по сути имитирует то, что видит человеческий глаз
 * Первый параметр определяет дальность от зрителя, чем больше параметр, тем "дальше" находятся объекты
 * Второй параметр отвечает за поворот по оси x. Т.е. при увеличении или уменьшении данного параметр, мы будем как будто объодить отрисованные объекты слева или справа
 * Третий параметр как бы отсекает изображение на указанном расстоянии от нас. т.е. если там будет указано 30, то это значит, что на расстоянии на 30 единиц от нас не будут отражаться объекты
 * Четвертый параметр работает по принципу третьего, только ограничивает всё после указанного расстояния, а не до
 */

var camera = new THREE.PerspectiveCamera(70, WIDTH/HEIGHT, 0.1, 1000000);
//Позиция z - это наша позиция как зрителя, т.е. расстояние до объектов составляет 50 единиц
camera.position.z = 50;
//В сцену добавляется камера
scene.add(camera);

/**
 * Библиотека предоставляет методы для создания объектов, например при помощи BoxGeometry создается кубоид
 * Первый параметр - длинна по оси x, второй - длинна по оси y, третий - длинна по оси z
 * Т.е. при указании например: 10, 20, 30 - мы получим прямоугольный параллепипед
 */
var boxGeometry = new THREE.BoxGeometry(10, 10, 10);
//Создаем экземпляр материала, в данном случае простоое закрашивание (данный способ не подвержен влиянию света)
var basicMaterial = new THREE.MeshBasicMaterial({color: 0xff6a4f});
//Класс Mesh предоставляет объекты на основе треугольной сетки
var cube = new THREE.Mesh(boxGeometry, basicMaterial);
/**
 * Далее двигаем куб по оси x, т.к. по умолчанию оно рендерится на середине экрана
 * задаем чере метод rotation вращение, где первый параметр вращение по x, второй по y, третий по z
 * добавляем куб в сцену
 */
cube.position.x = -25;
cube.rotation.set(0.3, 0.2, 0);
scene.add(cube);

/**
 * TorusGeometry создает объект типа тороид
 * Первый параметр - радиус
 * второй - радиус внутреннего пустого пространства
 * третий - количество радиальных сегментов, чем больше значении, тем более круглым будет торус в одной из проекций
 * четвертый - другие сегменты в другой проекции, действует по принципу третьего параметра
 */
var torusGeometry = new THREE.TorusGeometry(5, 1, 16, 100);
/**
 * Данный класс позволяет имитировать отражательную способность с зеркальными бликами, или блестящие поверхности
 * Например может использоваться для лакированного дерева
 */
var phongMaterial = new THREE.MeshPhongMaterial({color: 0xb52ff});
var torus = new THREE.Mesh(torusGeometry, phongMaterial);
scene.add(torus);

/**
 * DodecahedronGeometry создает правильный додекаэдр, который состоит из 12 правильных пятиугольников
 * Первый параметр указывает радиус додекаэдра
 */
var strangeGeometry = new THREE.DodecahedronGeometry(5);
// Данный класс позволяет имитировать отражательную способность, но без имитации блестящих поверхностей, или зеркальных бликов
var lambertMaterial = new THREE.MeshLambertMaterial({color: 0xff00});
var dodecahedron = new THREE.Mesh(strangeGeometry, lambertMaterial);
// Двигаем объект по оси x вправо, т.к. в центре уже имеется торус
dodecahedron.position.x = 25;
scene.add(dodecahedron);

//Создаем экземпляр класса света, в конструктоор передаем белый цвет
var light = new THREE.PointLight(0xFFFFFF);
//Устанавливаем где будет находиться источник света. В конструктор передаем x, y, z соответственно
light.position.set(-10, 15, 50);
scene.add(light);

//Переменная времени
var t = 0;
//Функция отрисовки сцены со всеми объектами и камеры, рендера
function render() {
    t += 0.01;
    //Функция самого JS, которая указывает браузеру на то, что необходимо произвести анимацию, параметром передаем функцию, которая вызывается, когда придет время обновлять анимацию
    requestAnimationFrame(render);
    //Вращаем куб по осям x и y, а торус по оси x
    cube.rotation.y += 0.01;
    cube.rotation.x += 0.01;
    torus.rotation.x += 0.01;
    //рассчитываем синусоиду по y, что позволит додекаэдру двигаться по оси y
    dodecahedron.position.y = 7*Math.sin(t*2);
    //Осуществляем само отображение объектов
    renderer.render(scene, camera);
}
//При запуске скрипта и инициализации всех объектов вызывается функция описанная выше
render();